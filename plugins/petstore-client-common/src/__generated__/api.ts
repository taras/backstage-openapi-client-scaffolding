/* eslint-disable */
// tslint:disable
/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.6
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

export namespace PetApi {
	export type AddPetResponse =
		| AddPet405Response
	
	export interface AddPet405Response {
		status: 405
		body?: undefined
		headers?: undefined
	}
	
	export interface DeletePetRequest {
		apiKey?: string
		/**
		 * @description <p>Pet id to delete</p>
		 * @type {number}
		 */
		petId: number
	}
	
	export type DeletePetResponse =
		| DeletePet400Response
		| DeletePet404Response
	
	export interface DeletePet400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface DeletePet404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type FindPetsByStatusResponse =
		| FindPetsByStatus200ApplicationJsonResponse
		| FindPetsByStatus200ApplicationXmlResponse
		| FindPetsByStatus400Response
	
	export interface FindPetsByStatus200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: Api.Pet[]
		headers?: undefined
	}
	
	export interface FindPetsByStatus200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		/* Unsupported mimeType for parsing */
		response: Response
		headers?: undefined
	}
	
	export interface FindPetsByStatus400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export type FindPetsByTagsResponse =
		| FindPetsByTags200ApplicationJsonResponse
		| FindPetsByTags200ApplicationXmlResponse
		| FindPetsByTags400Response
	
	export interface FindPetsByTags200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: Api.Pet[]
		headers?: undefined
	}
	
	export interface FindPetsByTags200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		/* Unsupported mimeType for parsing */
		response: Response
		headers?: undefined
	}
	
	export interface FindPetsByTags400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export type GetPetByIdResponse =
		| GetPetById200ApplicationJsonResponse
		| GetPetById200ApplicationXmlResponse
		| GetPetById400Response
		| GetPetById404Response
	
	export interface GetPetById200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: Api.Pet
		headers?: undefined
	}
	
	export interface GetPetById200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		/* Unsupported mimeType for parsing */
		response: Response
		headers?: undefined
	}
	
	export interface GetPetById400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface GetPetById404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type UpdatePetResponse =
		| UpdatePet400Response
		| UpdatePet404Response
		| UpdatePet405Response
	
	export interface UpdatePet400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface UpdatePet404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export interface UpdatePet405Response {
		status: 405
		body?: undefined
		headers?: undefined
	}
	
	export interface UpdatePetWithFormRequest {
		/**
		 * @description <p>ID of pet that needs to be updated</p>
		 * @type {number}
		 */
		petId: number
		/**
		 * @description <p>Updated name of the pet</p>
		 * @type {string}
		 */
		name?: string
		/**
		 * @description <p>Updated status of the pet</p>
		 * @type {string}
		 */
		status?: string
	}
	
	export type UpdatePetWithFormResponse =
		| UpdatePetWithForm405Response
	
	export interface UpdatePetWithForm405Response {
		status: 405
		body?: undefined
		headers?: undefined
	}
	
	export interface UploadFileRequest {
		/**
		 * @description <p>ID of pet to update</p>
		 * @type {number}
		 */
		petId: number
		/**
		 * @description <p>Additional data to pass to server</p>
		 * @type {string}
		 */
		additionalMetadata?: string
		/**
		 * @description <p>file to upload</p>
		 * @type {string | Blob}
		 */
		file?: string | Blob
	}
	
	export type UploadFileResponse =
		| UploadFile200Response
	
	export interface UploadFile200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ApiResponse
		headers?: undefined
	}
	
}

/**
 * PetApi - fetch parameter creator
 * @export
 */
export const PetApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @summary Add a new pet to the store
		 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		addPet(body: Api.Pet, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling addPet.');
			}

			let localVarPath = `/pet`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Deletes a pet
		 * @param {string} [apiKey]
		 * @param {number} petId <p>Pet id to delete</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		deletePet(__params: PetApi.DeletePetRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'petId' is not null or undefined
			if (__params.petId === null || __params.petId === undefined) {
				throw new RequiredError('petId', 'Required parameter petId was null or undefined when calling deletePet.');
			}

			let localVarPath = `/pet/{petId}`
				.replace('{petId}', encodeURIComponent(String(__params.petId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.apiKey !== undefined) {
				localVarHeaderParameter.append('api_key', String(__params.apiKey));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Multiple status values can be provided with comma separated strings</p>
		 * @summary Finds Pets by status
		 * @param {Api.FindPetsByStatusStatusEnum[]} status <p>Status values that need to be considered for filter</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		findPetsByStatus(status: Api.FindPetsByStatusStatusEnum[], options: RequestInit = {}): FetchArgs {
			// verify required parameter 'status' is not null or undefined
			if (status === null || status === undefined) {
				throw new RequiredError('status', 'Required parameter status was null or undefined when calling findPetsByStatus.');
			}

			let localVarPath = `/pet/findByStatus`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (status !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of status) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('status', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.</p>
		 * @summary Finds Pets by tags
		 * @param {string[]} tags <p>Tags to filter by</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 * @deprecated
		 */
		
		findPetsByTags(tags: string[], options: RequestInit = {}): FetchArgs {
			// verify required parameter 'tags' is not null or undefined
			if (tags === null || tags === undefined) {
				throw new RequiredError('tags', 'Required parameter tags was null or undefined when calling findPetsByTags.');
			}

			let localVarPath = `/pet/findByTags`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (tags !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of tags) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('tags', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Returns a single pet</p>
		 * @summary Find pet by ID
		 * @param {number} petId <p>ID of pet to return</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		getPetById(petId: number, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'petId' is not null or undefined
			if (petId === null || petId === undefined) {
				throw new RequiredError('petId', 'Required parameter petId was null or undefined when calling getPetById.');
			}

			let localVarPath = `/pet/{petId}`
				.replace('{petId}', encodeURIComponent(String(petId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication api_key required
			if (configuration && configuration.apiKey) {
				const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey('api_key')
					: configuration.apiKey;
				if (localVarApiKeyValue !== null) {
					localVarHeaderParameter.set('api_key', localVarApiKeyValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Update an existing pet
		 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		updatePet(body: Api.Pet, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling updatePet.');
			}

			let localVarPath = `/pet`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Updates a pet in the store with form data
		 * @param {number} petId <p>ID of pet that needs to be updated</p>
		 * @param {string} [name] <p>Updated name of the pet</p>
		 * @param {string} [status] <p>Updated status of the pet</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		updatePetWithForm(__params: PetApi.UpdatePetWithFormRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'petId' is not null or undefined
			if (__params.petId === null || __params.petId === undefined) {
				throw new RequiredError('petId', 'Required parameter petId was null or undefined when calling updatePetWithForm.');
			}

			let localVarPath = `/pet/{petId}`
				.replace('{petId}', encodeURIComponent(String(__params.petId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}
			const localVarFormParams = new URLSearchParams();

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.name !== undefined) {
				localVarFormParams.append('name', String(__params.name));
			}

			if (__params.status !== undefined) {
				localVarFormParams.append('status', String(__params.status));
			}

			localVarHeaderParameter.set('Content-Type', 'application/x-www-form-urlencoded');

			localVarRequestOptions.headers = localVarHeaderParameter;
			localVarRequestOptions.body = localVarFormParams.toString();

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary uploads an image
		 * @param {number} petId <p>ID of pet to update</p>
		 * @param {string} [additionalMetadata] <p>Additional data to pass to server</p>
		 * @param {string | Blob} [file] <p>file to upload</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		uploadFile(__params: PetApi.UploadFileRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'petId' is not null or undefined
			if (__params.petId === null || __params.petId === undefined) {
				throw new RequiredError('petId', 'Required parameter petId was null or undefined when calling uploadFile.');
			}

			let localVarPath = `/pet/{petId}/uploadImage`
				.replace('{petId}', encodeURIComponent(String(__params.petId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}
			const localVarFormParams = new URLSearchParams();

			// authentication petstore_auth required
			// oauth or openIdConnect required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('petstore_auth', ['write:pets', 'read:pets'])
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.additionalMetadata !== undefined) {
				localVarFormParams.append('additionalMetadata', String(__params.additionalMetadata));
			}

			if (__params.file !== undefined) {
				localVarFormParams.append('file', String(__params.file));
			}

			localVarHeaderParameter.set('Content-Type', 'application/x-www-form-urlencoded');

			localVarRequestOptions.headers = localVarHeaderParameter;
			localVarRequestOptions.body = localVarFormParams.toString();

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * PetApi - functional programming interface
 * @export
 */
export const PetApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @summary Add a new pet to the store
		 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPet(body: Api.Pet, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.AddPetResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).addPet(body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 405) {
					return {
						status: 405,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Deletes a pet
		 * @param {string} [apiKey]
		 * @param {number} petId <p>Pet id to delete</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deletePet(__params: PetApi.DeletePetRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.DeletePetResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).deletePet(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * <p>Multiple status values can be provided with comma separated strings</p>
		 * @summary Finds Pets by status
		 * @param {Api.FindPetsByStatusStatusEnum[]} status <p>Status values that need to be considered for filter</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findPetsByStatus(status: Api.FindPetsByStatusStatusEnum[], options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.FindPetsByStatusResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).findPetsByStatus(status, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Pet[],
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							/* Unsupported mimeType for parsing */
							response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * <p>Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.</p>
		 * @summary Finds Pets by tags
		 * @param {string[]} tags <p>Tags to filter by</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 * @deprecated
		 */
		findPetsByTags(tags: string[], options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.FindPetsByTagsResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).findPetsByTags(tags, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Pet[],
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							/* Unsupported mimeType for parsing */
							response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * <p>Returns a single pet</p>
		 * @summary Find pet by ID
		 * @param {number} petId <p>ID of pet to return</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPetById(petId: number, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.GetPetByIdResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).getPetById(petId, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Pet,
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							/* Unsupported mimeType for parsing */
							response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Update an existing pet
		 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updatePet(body: Api.Pet, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.UpdatePetResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).updatePet(body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				if (response.status === 405) {
					return {
						status: 405,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Updates a pet in the store with form data
		 * @param {number} petId <p>ID of pet that needs to be updated</p>
		 * @param {string} [name] <p>Updated name of the pet</p>
		 * @param {string} [status] <p>Updated status of the pet</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updatePetWithForm(__params: PetApi.UpdatePetWithFormRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.UpdatePetWithFormResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).updatePetWithForm(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 405) {
					return {
						status: 405,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary uploads an image
		 * @param {number} petId <p>ID of pet to update</p>
		 * @param {string} [additionalMetadata] <p>Additional data to pass to server</p>
		 * @param {string | Blob} [file] <p>file to upload</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		uploadFile(__params: PetApi.UploadFileRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PetApi.UploadFileResponse> {
			const localVarFetchArgs = PetApiFetchParamCreator(configuration).uploadFile(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.ApiResponse,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * PetApi - factory interface
 * @export
 */
export const PetApiFactory: FactoryFunction<PetApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new PetApi(configuration, basePath, fetch);
};

/**
 * PetApi - interface
 * @export
 * @interface PetApi
 */
export interface PetApiInterface {
	/**
	 * @summary Add a new pet to the store
	 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	addPet(body: Api.Pet, options?: RequestInit): Promise<PetApi.AddPetResponse>

	/**
	 * @summary Deletes a pet
	 * @param {string} [apiKey]
	 * @param {number} petId <p>Pet id to delete</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deletePet(__params: PetApi.DeletePetRequest, options?: RequestInit): Promise<PetApi.DeletePetResponse>

	/**
	 * <p>Multiple status values can be provided with comma separated strings</p>
	 * @summary Finds Pets by status
	 * @param {Api.FindPetsByStatusStatusEnum[]} status <p>Status values that need to be considered for filter</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	findPetsByStatus(status: Api.FindPetsByStatusStatusEnum[], options?: RequestInit): Promise<PetApi.FindPetsByStatusResponse>

	/**
	 * <p>Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.</p>
	 * @summary Finds Pets by tags
	 * @param {string[]} tags <p>Tags to filter by</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 * @deprecated
	 */
	findPetsByTags(tags: string[], options?: RequestInit): Promise<PetApi.FindPetsByTagsResponse>

	/**
	 * <p>Returns a single pet</p>
	 * @summary Find pet by ID
	 * @param {number} petId <p>ID of pet to return</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getPetById(petId: number, options?: RequestInit): Promise<PetApi.GetPetByIdResponse>

	/**
	 * @summary Update an existing pet
	 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updatePet(body: Api.Pet, options?: RequestInit): Promise<PetApi.UpdatePetResponse>

	/**
	 * @summary Updates a pet in the store with form data
	 * @param {number} petId <p>ID of pet that needs to be updated</p>
	 * @param {string} [name] <p>Updated name of the pet</p>
	 * @param {string} [status] <p>Updated status of the pet</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updatePetWithForm(__params: PetApi.UpdatePetWithFormRequest, options?: RequestInit): Promise<PetApi.UpdatePetWithFormResponse>

	/**
	 * @summary uploads an image
	 * @param {number} petId <p>ID of pet to update</p>
	 * @param {string} [additionalMetadata] <p>Additional data to pass to server</p>
	 * @param {string | Blob} [file] <p>file to upload</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	uploadFile(__params: PetApi.UploadFileRequest, options?: RequestInit): Promise<PetApi.UploadFileResponse>

}

/**
 * PetApi - object-oriented interface
 * @export
 * @class PetApi
 * @extends {BaseAPI}
 */
export class PetApi extends BaseAPI implements PetApiInterface {
	/**
	 * @summary Add a new pet to the store
	 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public addPet(body: Api.Pet, options?: RequestInit) {
		return PetApiFp(this.configuration).addPet(body, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Deletes a pet
	 * @param {string} [apiKey]
	 * @param {number} petId <p>Pet id to delete</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deletePet(__params: PetApi.DeletePetRequest, options?: RequestInit) {
		return PetApiFp(this.configuration).deletePet(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Multiple status values can be provided with comma separated strings</p>
	 * @summary Finds Pets by status
	 * @param {Api.FindPetsByStatusStatusEnum[]} status <p>Status values that need to be considered for filter</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public findPetsByStatus(status: Api.FindPetsByStatusStatusEnum[], options?: RequestInit) {
		return PetApiFp(this.configuration).findPetsByStatus(status, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.</p>
	 * @summary Finds Pets by tags
	 * @param {string[]} tags <p>Tags to filter by</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 * @deprecated
	 */
	public findPetsByTags(tags: string[], options?: RequestInit) {
		return PetApiFp(this.configuration).findPetsByTags(tags, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Returns a single pet</p>
	 * @summary Find pet by ID
	 * @param {number} petId <p>ID of pet to return</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getPetById(petId: number, options?: RequestInit) {
		return PetApiFp(this.configuration).getPetById(petId, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Update an existing pet
	 * @param {Api.Pet} body <p>Pet object that needs to be added to the store</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updatePet(body: Api.Pet, options?: RequestInit) {
		return PetApiFp(this.configuration).updatePet(body, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Updates a pet in the store with form data
	 * @param {number} petId <p>ID of pet that needs to be updated</p>
	 * @param {string} [name] <p>Updated name of the pet</p>
	 * @param {string} [status] <p>Updated status of the pet</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updatePetWithForm(__params: PetApi.UpdatePetWithFormRequest, options?: RequestInit) {
		return PetApiFp(this.configuration).updatePetWithForm(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary uploads an image
	 * @param {number} petId <p>ID of pet to update</p>
	 * @param {string} [additionalMetadata] <p>Additional data to pass to server</p>
	 * @param {string | Blob} [file] <p>file to upload</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public uploadFile(__params: PetApi.UploadFileRequest, options?: RequestInit) {
		return PetApiFp(this.configuration).uploadFile(__params, options)(this.fetch, this.basePath);
	}

}
export namespace StoreApi {
	export type DeleteOrderResponse =
		| DeleteOrder400Response
		| DeleteOrder404Response
	
	export interface DeleteOrder400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteOrder404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type GetInventoryResponse =
		| GetInventory200Response
	
	export interface GetInventory200Response {
		status: 200
		contentType: 'application/json'
		body: { [name: string]: number }
		headers?: undefined
	}
	
	export type GetOrderByIdResponse =
		| GetOrderById200ApplicationJsonResponse
		| GetOrderById200ApplicationXmlResponse
		| GetOrderById400Response
		| GetOrderById404Response
	
	export interface GetOrderById200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: Api.Order
		headers?: undefined
	}
	
	export interface GetOrderById200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		/* Unsupported mimeType for parsing */
		response: Response
		headers?: undefined
	}
	
	export interface GetOrderById400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface GetOrderById404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type PlaceOrderResponse =
		| PlaceOrder200ApplicationJsonResponse
		| PlaceOrder200ApplicationXmlResponse
		| PlaceOrder400Response
	
	export interface PlaceOrder200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: Api.Order
		headers?: undefined
	}
	
	export interface PlaceOrder200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		/* Unsupported mimeType for parsing */
		response: Response
		headers?: undefined
	}
	
	export interface PlaceOrder400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
}

/**
 * StoreApi - fetch parameter creator
 * @export
 */
export const StoreApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors</p>
		 * @summary Delete purchase order by ID
		 * @param {number} orderId <p>ID of the order that needs to be deleted</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		deleteOrder(orderId: number, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'orderId' is not null or undefined
			if (orderId === null || orderId === undefined) {
				throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling deleteOrder.');
			}

			let localVarPath = `/store/order/{orderId}`
				.replace('{orderId}', encodeURIComponent(String(orderId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Returns a map of status codes to quantities</p>
		 * @summary Returns pet inventories by status
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		getInventory(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/store/inventory`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication api_key required
			if (configuration && configuration.apiKey) {
				const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey('api_key')
					: configuration.apiKey;
				if (localVarApiKeyValue !== null) {
					localVarHeaderParameter.set('api_key', localVarApiKeyValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>For valid response try integer IDs with value &gt;= 1 and &lt;= 10. Other values will generated exceptions</p>
		 * @summary Find purchase order by ID
		 * @param {number} orderId <p>ID of pet that needs to be fetched</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		getOrderById(orderId: number, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'orderId' is not null or undefined
			if (orderId === null || orderId === undefined) {
				throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling getOrderById.');
			}

			let localVarPath = `/store/order/{orderId}`
				.replace('{orderId}', encodeURIComponent(String(orderId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Place an order for a pet
		 * @param {Api.Order} body <p>order placed for purchasing the pet</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		placeOrder(body: Api.Order, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling placeOrder.');
			}

			let localVarPath = `/store/order`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors</p>
		 * @summary Delete purchase order by ID
		 * @param {number} orderId <p>ID of the order that needs to be deleted</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOrder(orderId: number, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<StoreApi.DeleteOrderResponse> {
			const localVarFetchArgs = StoreApiFetchParamCreator(configuration).deleteOrder(orderId, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * <p>Returns a map of status codes to quantities</p>
		 * @summary Returns pet inventories by status
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getInventory(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<StoreApi.GetInventoryResponse> {
			const localVarFetchArgs = StoreApiFetchParamCreator(configuration).getInventory(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as { [name: string]: number },
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>For valid response try integer IDs with value &gt;= 1 and &lt;= 10. Other values will generated exceptions</p>
		 * @summary Find purchase order by ID
		 * @param {number} orderId <p>ID of pet that needs to be fetched</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOrderById(orderId: number, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<StoreApi.GetOrderByIdResponse> {
			const localVarFetchArgs = StoreApiFetchParamCreator(configuration).getOrderById(orderId, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Order,
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							/* Unsupported mimeType for parsing */
							response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Place an order for a pet
		 * @param {Api.Order} body <p>order placed for purchasing the pet</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		placeOrder(body: Api.Order, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<StoreApi.PlaceOrderResponse> {
			const localVarFetchArgs = StoreApiFetchParamCreator(configuration).placeOrder(body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Order,
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							/* Unsupported mimeType for parsing */
							response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				throw response;
			};
		},
	}
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory: FactoryFunction<StoreApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new StoreApi(configuration, basePath, fetch);
};

/**
 * StoreApi - interface
 * @export
 * @interface StoreApi
 */
export interface StoreApiInterface {
	/**
	 * <p>For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors</p>
	 * @summary Delete purchase order by ID
	 * @param {number} orderId <p>ID of the order that needs to be deleted</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteOrder(orderId: number, options?: RequestInit): Promise<StoreApi.DeleteOrderResponse>

	/**
	 * <p>Returns a map of status codes to quantities</p>
	 * @summary Returns pet inventories by status
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getInventory(options?: RequestInit): Promise<StoreApi.GetInventoryResponse>

	/**
	 * <p>For valid response try integer IDs with value &gt;= 1 and &lt;= 10. Other values will generated exceptions</p>
	 * @summary Find purchase order by ID
	 * @param {number} orderId <p>ID of pet that needs to be fetched</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getOrderById(orderId: number, options?: RequestInit): Promise<StoreApi.GetOrderByIdResponse>

	/**
	 * @summary Place an order for a pet
	 * @param {Api.Order} body <p>order placed for purchasing the pet</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	placeOrder(body: Api.Order, options?: RequestInit): Promise<StoreApi.PlaceOrderResponse>

}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI implements StoreApiInterface {
	/**
	 * <p>For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors</p>
	 * @summary Delete purchase order by ID
	 * @param {number} orderId <p>ID of the order that needs to be deleted</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteOrder(orderId: number, options?: RequestInit) {
		return StoreApiFp(this.configuration).deleteOrder(orderId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Returns a map of status codes to quantities</p>
	 * @summary Returns pet inventories by status
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getInventory(options?: RequestInit) {
		return StoreApiFp(this.configuration).getInventory(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>For valid response try integer IDs with value &gt;= 1 and &lt;= 10. Other values will generated exceptions</p>
	 * @summary Find purchase order by ID
	 * @param {number} orderId <p>ID of pet that needs to be fetched</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getOrderById(orderId: number, options?: RequestInit) {
		return StoreApiFp(this.configuration).getOrderById(orderId, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Place an order for a pet
	 * @param {Api.Order} body <p>order placed for purchasing the pet</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public placeOrder(body: Api.Order, options?: RequestInit) {
		return StoreApiFp(this.configuration).placeOrder(body, options)(this.fetch, this.basePath);
	}

}
export namespace UserApi {
	export type CreateUserResponse =
		| CreateUser200Response
	
	export interface CreateUser200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type CreateUsersWithArrayInputResponse =
		| CreateUsersWithArrayInput200Response
	
	export interface CreateUsersWithArrayInput200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type CreateUsersWithListInputResponse =
		| CreateUsersWithListInput200Response
	
	export interface CreateUsersWithListInput200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type DeleteUserResponse =
		| DeleteUser400Response
		| DeleteUser404Response
	
	export interface DeleteUser400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface DeleteUser404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export type GetUserByNameResponse =
		| GetUserByName200ApplicationJsonResponse
		| GetUserByName200ApplicationXmlResponse
		| GetUserByName400Response
		| GetUserByName404Response
	
	export interface GetUserByName200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: Api.User
		headers?: undefined
	}
	
	export interface GetUserByName200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		/* Unsupported mimeType for parsing */
		response: Response
		headers?: undefined
	}
	
	export interface GetUserByName400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface GetUserByName404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
	export interface LoginUserRequest {
		/**
		 * @description <p>The user name for login</p>
		 * @type {string}
		 */
		username: string
		/**
		 * @description <p>The password for login in clear text</p>
		 * @type {string}
		 */
		password: string
	}
	
	export type LoginUserResponse =
		| LoginUser200ApplicationJsonResponse
		| LoginUser200ApplicationXmlResponse
		| LoginUser400Response
	
	export interface LoginUser200ApplicationJsonResponse {
		status: 200
		contentType: 'application/json'
		body: string
		headers: {
			'xExpiresAfter': Date
			'xRateLimit': number
		}
	}
	
	export interface LoginUser200ApplicationXmlResponse {
		status: 200
		contentType: 'application/xml'
		body: string
		headers: {
			'xExpiresAfter': Date
			'xRateLimit': number
		}
	}
	
	export interface LoginUser400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export type LogoutUserResponse =
		| LogoutUser200Response
	
	export interface LogoutUser200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
	export type UpdateUserResponse =
		| UpdateUser400Response
		| UpdateUser404Response
	
	export interface UpdateUser400Response {
		status: 400
		body?: undefined
		headers?: undefined
	}
	
	export interface UpdateUser404Response {
		status: 404
		body?: undefined
		headers?: undefined
	}
	
}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>This can only be done by the logged in user.</p>
		 * @summary Create user
		 * @param {Api.User} body <p>Created user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		createUser(body: Api.User, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling createUser.');
			}

			let localVarPath = `/user`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Creates list of users with given input array
		 * @param {Api.User[]} body <p>List of user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		createUsersWithArrayInput(body: Api.User[], options: RequestInit = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling createUsersWithArrayInput.');
			}

			let localVarPath = `/user/createWithArray`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Creates list of users with given input array
		 * @param {Api.User[]} body <p>List of user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		createUsersWithListInput(body: Api.User[], options: RequestInit = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling createUsersWithListInput.');
			}

			let localVarPath = `/user/createWithList`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>This can only be done by the logged in user.</p>
		 * @summary Delete user
		 * @param {string} username <p>The name that needs to be deleted</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		deleteUser(username: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'username' is not null or undefined
			if (username === null || username === undefined) {
				throw new RequiredError('username', 'Required parameter username was null or undefined when calling deleteUser.');
			}

			let localVarPath = `/user/{username}`
				.replace('{username}', encodeURIComponent(String(username)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Get user by user name
		 * @param {string} username <p>The name that needs to be fetched. Use user1 for testing. </p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		getUserByName(username: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'username' is not null or undefined
			if (username === null || username === undefined) {
				throw new RequiredError('username', 'Required parameter username was null or undefined when calling getUserByName.');
			}

			let localVarPath = `/user/{username}`
				.replace('{username}', encodeURIComponent(String(username)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Logs user into the system
		 * @param {string} username <p>The user name for login</p>
		 * @param {string} password <p>The password for login in clear text</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		loginUser(__params: UserApi.LoginUserRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'username' is not null or undefined
			if (__params.username === null || __params.username === undefined) {
				throw new RequiredError('username', 'Required parameter username was null or undefined when calling loginUser.');
			}
			// verify required parameter 'password' is not null or undefined
			if (__params.password === null || __params.password === undefined) {
				throw new RequiredError('password', 'Required parameter password was null or undefined when calling loginUser.');
			}

			let localVarPath = `/user/login`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.username !== undefined) {
				localVarQueryParameter.append('username', String(__params.username));
			}

			if (__params.password !== undefined) {
				localVarQueryParameter.append('password', String(__params.password));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @summary Logs out current logged in user session
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		logoutUser(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/user/logout`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>This can only be done by the logged in user.</p>
		 * @summary Updated user
		 * @param {string} username <p>name that need to be updated</p>
		 * @param {Api.User} body <p>Updated user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		
		updateUser(username: string, body: Api.User, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'username' is not null or undefined
			if (username === null || username === undefined) {
				throw new RequiredError('username', 'Required parameter username was null or undefined when calling updateUser.');
			}
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateUser.');
			}

			let localVarPath = `/user/{username}`
				.replace('{username}', encodeURIComponent(String(username)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'PUT' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (body !== undefined) {
				localVarRequestOptions.body = JSON.stringify(body || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>This can only be done by the logged in user.</p>
		 * @summary Create user
		 * @param {Api.User} body <p>Created user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUser(body: Api.User, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.CreateUserResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUser(body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: 200,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Creates list of users with given input array
		 * @param {Api.User[]} body <p>List of user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUsersWithArrayInput(body: Api.User[], options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.CreateUsersWithArrayInputResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUsersWithArrayInput(body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: 200,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Creates list of users with given input array
		 * @param {Api.User[]} body <p>List of user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUsersWithListInput(body: Api.User[], options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.CreateUsersWithListInputResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUsersWithListInput(body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: 200,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * <p>This can only be done by the logged in user.</p>
		 * @summary Delete user
		 * @param {string} username <p>The name that needs to be deleted</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteUser(username: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.DeleteUserResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(username, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Get user by user name
		 * @param {string} username <p>The name that needs to be fetched. Use user1 for testing. </p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserByName(username: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.GetUserByNameResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserByName(username, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.User,
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							/* Unsupported mimeType for parsing */
							response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Logs user into the system
		 * @param {string} username <p>The user name for login</p>
		 * @param {string} password <p>The password for login in clear text</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginUser(__params: UserApi.LoginUserRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.LoginUserResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).loginUser(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as string,
							headers: {
								xExpiresAfter: response.headers.get('X-Expires-After'),
								xRateLimit: response.headers.get('X-Rate-Limit'),
							},
						}
					}
					if (mimeType === 'application/xml') {
						return {
							status: 200,
							contentType: 'application/xml',
							body: await response.text(),
							headers: {
								xExpiresAfter: response.headers.get('X-Expires-After'),
								xRateLimit: response.headers.get('X-Rate-Limit'),
							},
						}
					}
					throw response;
				}
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @summary Logs out current logged in user session
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutUser(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.LogoutUserResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).logoutUser(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: 200,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * <p>This can only be done by the logged in user.</p>
		 * @summary Updated user
		 * @param {string} username <p>name that need to be updated</p>
		 * @param {Api.User} body <p>Updated user object</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateUser(username: string, body: Api.User, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<UserApi.UpdateUserResponse> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(username, body, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 400) {
					return {
						status: 400,
						/* No content */
					}
				}
				if (response.status === 404) {
					return {
						status: 404,
						/* No content */
					}
				}
				throw response;
			};
		},
	}
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory: FactoryFunction<UserApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new UserApi(configuration, basePath, fetch);
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
	/**
	 * <p>This can only be done by the logged in user.</p>
	 * @summary Create user
	 * @param {Api.User} body <p>Created user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createUser(body: Api.User, options?: RequestInit): Promise<UserApi.CreateUserResponse>

	/**
	 * @summary Creates list of users with given input array
	 * @param {Api.User[]} body <p>List of user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createUsersWithArrayInput(body: Api.User[], options?: RequestInit): Promise<UserApi.CreateUsersWithArrayInputResponse>

	/**
	 * @summary Creates list of users with given input array
	 * @param {Api.User[]} body <p>List of user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createUsersWithListInput(body: Api.User[], options?: RequestInit): Promise<UserApi.CreateUsersWithListInputResponse>

	/**
	 * <p>This can only be done by the logged in user.</p>
	 * @summary Delete user
	 * @param {string} username <p>The name that needs to be deleted</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteUser(username: string, options?: RequestInit): Promise<UserApi.DeleteUserResponse>

	/**
	 * @summary Get user by user name
	 * @param {string} username <p>The name that needs to be fetched. Use user1 for testing. </p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getUserByName(username: string, options?: RequestInit): Promise<UserApi.GetUserByNameResponse>

	/**
	 * @summary Logs user into the system
	 * @param {string} username <p>The user name for login</p>
	 * @param {string} password <p>The password for login in clear text</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	loginUser(__params: UserApi.LoginUserRequest, options?: RequestInit): Promise<UserApi.LoginUserResponse>

	/**
	 * @summary Logs out current logged in user session
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	logoutUser(options?: RequestInit): Promise<UserApi.LogoutUserResponse>

	/**
	 * <p>This can only be done by the logged in user.</p>
	 * @summary Updated user
	 * @param {string} username <p>name that need to be updated</p>
	 * @param {Api.User} body <p>Updated user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	updateUser(username: string, body: Api.User, options?: RequestInit): Promise<UserApi.UpdateUserResponse>

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
	/**
	 * <p>This can only be done by the logged in user.</p>
	 * @summary Create user
	 * @param {Api.User} body <p>Created user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createUser(body: Api.User, options?: RequestInit) {
		return UserApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Creates list of users with given input array
	 * @param {Api.User[]} body <p>List of user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createUsersWithArrayInput(body: Api.User[], options?: RequestInit) {
		return UserApiFp(this.configuration).createUsersWithArrayInput(body, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Creates list of users with given input array
	 * @param {Api.User[]} body <p>List of user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createUsersWithListInput(body: Api.User[], options?: RequestInit) {
		return UserApiFp(this.configuration).createUsersWithListInput(body, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>This can only be done by the logged in user.</p>
	 * @summary Delete user
	 * @param {string} username <p>The name that needs to be deleted</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteUser(username: string, options?: RequestInit) {
		return UserApiFp(this.configuration).deleteUser(username, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Get user by user name
	 * @param {string} username <p>The name that needs to be fetched. Use user1 for testing. </p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getUserByName(username: string, options?: RequestInit) {
		return UserApiFp(this.configuration).getUserByName(username, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Logs user into the system
	 * @param {string} username <p>The user name for login</p>
	 * @param {string} password <p>The password for login in clear text</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public loginUser(__params: UserApi.LoginUserRequest, options?: RequestInit) {
		return UserApiFp(this.configuration).loginUser(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @summary Logs out current logged in user session
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public logoutUser(options?: RequestInit) {
		return UserApiFp(this.configuration).logoutUser(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>This can only be done by the logged in user.</p>
	 * @summary Updated user
	 * @param {string} username <p>name that need to be updated</p>
	 * @param {Api.User} body <p>Updated user object</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public updateUser(username: string, body: Api.User, options?: RequestInit) {
		return UserApiFp(this.configuration).updateUser(username, body, options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
